<!DOCTYPE html>
<html>
<head>
    <title>3V-MM</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />

<script src='https://abubujs.org/libs/Abubu.latest.js' 
        type='text/javascript'></script>
<!-- editors and jQuery -->
<script 
src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js'  
type="text/javascript" charset="utf-8">
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/mode-glsl.js'>
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/theme-tomorrow.js'>
</script>
<script
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/keybinding-vim.js'>
</script>
<script 
    src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>


<style>/* unvisited link */
a:link {
    	color: blue;
}

/* visited link */
a:visited {
    	color: blue;
}

/* mouse over link */
a:hover {
    	color: hotpink;
}

/* selected link */
a:active {
    	color: blue;
}
/*
li{
    	margin : 10px 6px ;
} */

body {
	counter-reset: h1;
}


h1{
        max-width: 1024px ;
	text-align:left;
	color: white;
       	background-color: #00254c;
       	padding-left: 20px ;
       	padding-top: 10px ;
       	padding-bottom: 10px ;
       	border-radius: 10px;
}

h2 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #e5e5e5 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;

    	border-radius: 10px;
}

h3 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #f0f0f0 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

h4 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #fafafa ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

p{
    max-width : 700px  ;
    padding-left: 10px ;
}
canvas.clickable:hover{
    cursor:pointer ;
    cursor:hand ;
}

.footer{
    position : fixed ; 
    max-width: 1024px ;
    border-radius:10px ;
    left : 0px ;
    width : 100% ;
    background-color: #fafafa;
    color:black ;
    bottom: 0px ;
    text-align : left ;
    font: 'italic 12pt Times' ;
}

div.relative {
    position: relative;
    width:100% ;
    min-height : 600px ;
    max-height : 100% ;
    max-width: 1024px
} 

div.editor {
    position    : absolute ;
    margin-left : 20px ;
    width       : 90%;
    height      : 100% ;
    border      : 3px solid grey;
    border-radius: 10px ;
}

#loading { 
    position : fixed ;
    bottom : 20px ;
    left : 10px ;
}

#loadProgress {
    width : 300px ;
    background-color: #ddd ;
}

#loadBar {
    width : 0% ;
    height : 20px ;
    background-color: #4caf50 ;
    border-radius: 3px ;
}

</style>
</head>
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- body of the html page                                             -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<body>
    <h1>3D 3-Variable Minimal Model</h1>
    <!--
    <div id='chooser'>
        <h2>Select the JSON file containing the structure</h2>
        <p style='color:red'>Before you can proceed, you need to choose the structural
        file!</p>
       <input type='file' id='json_structure' accept='.json, .JSON'></input>
    </div> -->

    <table>
        <tr>
            <td>
                <canvas id=canvas_1 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
            <td>
                <canvas id=canvas_2 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
        </tr>
    </table>
    
    <div class='relative' id='editorSection' style='display:none'>
        <h2>Source code editor</h2>
        <div class='editor' id='editor'></div>
    </div>
    
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- All shaders included here (codes written in GLSL)                 -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- ***************************************************************** -->
<script id='directionator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * directionator.frag : find North, South, East, West, Up and Down
 * dirction indices 
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Sat 06 Mar 2021 21:02:53 (EST)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp int ;
precision highp float ;
precision highp sampler2D ;
precision highp usampler2D ;

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )


/*-------------------------------------------------------------------------
 * interfacial variables
 *-------------------------------------------------------------------------
 */
in vec2 cc ;

uniform usampler2D fullTexelIndex, compressedTexelIndex ;
uniform int mx, my ;

/*------------------------------------------------------------------------
 * output colors
 *------------------------------------------------------------------------
 */
layout (location = 0) out uvec4 odir0 ;
layout (location = 1) out uvec4 odir1 ;

/*========================================================================
 * getIJ: return the IJ index on the full 2d-matrix
 *========================================================================
 */
ivec2 getIJ(ivec3 idx, ivec3 size){
    int si = idx.z % mx ;
    int sj = idx.z / mx ;

    return ivec2(size.x*si + idx.x, (my-1-sj)*size.y + idx.y) ;
}

/*========================================================================
 * getIdx: get the 3d index from the IJ indices
 *========================================================================
 */
ivec3 getIdx( ivec2 IJ, ivec3 size ){
    int si = IJ.x / size.x ;
    int sj = (my - 1) - (IJ.y/size.y) ;

    return ivec3( IJ.x % size.x, IJ.y % size.y , mx*sj + si ) ;
}

/*========================================================================
 * macros 
 *========================================================================
 */
#define isInBounds( v )     (all(greaterThanEqual(v,ivec3(0))) && \
        all(lessThan(v,size)))

#define texelInDomain(I)  ( texelFetch(compressedTexelIndex,(I),\
            0).a==uint(1) )
#define inDomain( v )   (texelInDomain( getIJ(v, size) )) 
#define isNotGood(v)   (!( inDomain(v) && isInBounds( v ) ))

/*========================================================================
 * getPackedIndex: get packed index of the point by applying the zero-flux
 * condition.
 *========================================================================
 */
uint getPackedIndex( ivec3 C, ivec3 D, ivec3 size ){
    ivec3 checkPoint = C+D ;
    
    if ( isNotGood(checkPoint) ){ /* if that direction is not good move in
                                     the opposite direction */
        checkPoint = C-D ;
        if ( isNotGood( checkPoint ) ){ /* if the opposite direction is
                                           not good either, use the
                                           central point coordinate */
            checkPoint = C ;
        }
    }
    uvec2 targetIndex = texelFetch(
            compressedTexelIndex,
            getIJ(checkPoint,size),
            0 ).xy ;
    return pack(targetIndex.x,targetIndex.y) ;  
}

/*========================================================================
 * main
 *========================================================================
 */
void main(){
    // get the sizes of the compressed and the full domain ...............
    ivec2 compSize = textureSize(fullTexelIndex,        0 ) ;
    ivec2 fullSize = textureSize(compressedTexelIndex,  0 ) ;

    // calculate the resolution of the full domain .......................
    ivec3 size = ivec3( fullSize.x/mx , fullSize.y/my, mx*my ) ;

    // get the textel position and full texel index ......................
    ivec2 texelPos = ivec2( cc*vec2(compSize) ) ; 
    ivec4 fullTexelIndex = 
        ivec4( texelFetch(  fullTexelIndex, texelPos, 0) ) ;

    // if the texel is extra, just leave .................................
    if ( fullTexelIndex.a != 1 ){
        return ;
    }
    
    // 3-dimentional index of the of texel ...............................
    ivec3 cidx = getIdx( fullTexelIndex.xy , size ) ;

    // diretionional vectors .............................................
    ivec3 ii = ivec3(1,0,0) ;
    ivec3 jj = ivec3(0,1,0) ;
    ivec3 kk = ivec3(0,0,1) ;

    // calculating the packed indices of the each compute point ..........
    uvec4 dir0 , dir1 ;
   
    NORTH = getPackedIndex( cidx, jj, size) ; // north direction
    SOUTH = getPackedIndex( cidx,-jj, size) ; // south direction
    EAST  = getPackedIndex( cidx, ii, size) ; // east  direction
    WEST  = getPackedIndex( cidx,-ii, size) ; // west  direction

    UP    = getPackedIndex( cidx, kk, size) ; // up   direction
    DOWN  = getPackedIndex( cidx,-kk, size) ; // down direction

    // outputing the calculated points ...................................
    odir0 = uvec4(dir0) ;
    odir1 = uvec4(dir1) ;

    return ;
}
</script><!-- end of directionator shader's source code -->

<!-- ***************************************************************** -->
<script id='initSolution' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * initSolution : initialize the solution 
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 14 Apr 2021 18:29:01 (EDT)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp int ;
precision highp float ;
precision highp sampler2D ;
precision highp usampler2D ;


#define vlt     color0.r
#define fig     color0.g
#define sig     color0.b
#define time    color0.a
#define MAX_TIME    1.e8


#define vlt_txtr icolor0
#define vchannel r


// interface variables ...................................................
in vec2 cc ;

// ouput color ...........................................................
out vec4 ocolor0 ;

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    vec4 color0 ;

    vlt = 0. ;
    fig = 1. ;
    sig = 0.4 ;
    time = MAX_TIME ;

    ocolor0 = vec4(color0) ;
    return ;
}
</script><!-- end of initSolution shader's source code -->

<!-- ***************************************************************** -->
<script id='computeTimeStep' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * computeTimeStep : march the the solution for one time-step
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 14 Apr 2021 18:32:25 (EDT)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp int ;
precision highp float ;
precision highp sampler2D ;
precision highp usampler2D ;


/*------------------------------------------------------------------------
 * interface variables
 *------------------------------------------------------------------------
 */
in vec2 cc ;

// uniforms ..............................................................
uniform float   tau_pv, tau_v1, tau_v2, tau_pw, tau_mw, tau_d, tau_0, 
                tau_r,  tau_si, K,      V_sic,  V_c,    V_v ,  C_si ;

uniform float   dt, lx, diffCoef, C_m ;
uniform float   pacemakerPositionX ;
uniform float   pacemakerPositionY ;
uniform float   pacemakerPeriod ;
uniform float   pacemakerRadius ;
uniform bool    pacemakerActive ;

uniform sampler2D   icolor0 ;

uniform int     resolution ;// resolution in all directions
uniform int     mx, my ;    /* number of z-layers in S and T directions 
                               of the textures */

// directional information ...............................................
uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



// coordinate of the system ..............................................
uniform sampler2D   compressed3dCrdt ;

// output colors .........................................................
out vec4 ocolor0 ;

// variable macros .......................................................
#define vlt     color0.r
#define fig     color0.g
#define sig     color0.b
#define time    color0.a
#define MAX_TIME    1.e8


#define vlt_txtr icolor0
#define vchannel r


#define isInBounds(v)  (all(greaterThanEqual(v,ivec2(0))) && \
        all(lessThan(v,size)))
#define isInDomain(I)   ((texelFetch(domain, I, 0).r>0.5) && \
        isInBounds(I))

/*========================================================================
 * main body fo the shader
 *========================================================================
 */
void main(){
    // extract pixel values from textures ................................
    ivec2 isize = textureSize(icolor0,        0 ) ;
    ivec2 texelPos = ivec2( cc*vec2(isize) ) ; 
    //ivec2 texelPos = ivec2( cc*vec2(size) ) ;

    // localize variables ................................................
    vec4 color0 = texelFetch( icolor0 , texelPos , 0) ; 

    uvec4 dir0  = texelFetch( idir0 , texelPos,0 ) ;
    uvec4 dir1  = texelFetch( idir1 , texelPos,0 ) ;

    // Calculating right hand side vars ..................................
    float p = step(V_c, vlt) ;
    float q = step(V_v, vlt) ;

    float tau_mv = (1.0-q)*tau_v1   +  q*tau_v2 ;

    float Ifi  = -fig*p*(vlt - V_c)*(1.0-vlt)/tau_d ;
    float Iso  =  vlt*(1.0  - p )/tau_0 + p/tau_r ;

    float tn = tanh(K*(vlt-V_sic)) ;
    float Isi  = -sig*(1.0  + tn) /(2.0*tau_si) ;
    Isi *= C_si ;

    float I_sum = Isi + Ifi + Iso ;

    float dFig2dt  = (1.0-p)*(1.0-fig)/tau_mv - p*fig/tau_pv ;
    float dSig2dt  = (1.0-p)*(1.0-sig)/tau_mw - p*sig/tau_pw ;

    fig += dFig2dt*dt ;
    sig += dSig2dt*dt ;

    // diffusion .........................................................
    float  dx = lx/float(mx*my) ;

    float laplacian = (
            texelFetch( vlt_txtr, unpack( NORTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( SOUTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( EAST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( WEST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( UP    ), 0 )
        +   texelFetch( vlt_txtr, unpack( DOWN  ), 0 )
        -6.*texelFetch( vlt_txtr, texelPos, 0 )         ).vchannel ;

    laplacian = laplacian/(dx*dx) ;


    float dVlt2dt = laplacian*diffCoef ;

    dVlt2dt -= I_sum/C_m ;

    // march membrane potential using euler time-stepping ................
    vlt += dVlt2dt*dt ;

    // update solution time ..............................................
    time += dt ;

    if ( time > pacemakerPeriod ){
        time = 0. ;
        
        if ( length(vec2(pacemakerPositionX,pacemakerPositionY)
                    - cc )< pacemakerRadius && pacemakerActive ){
            vlt = 1. ;
        }
    }

    // output colors .....................................................
    ocolor0 = vec4(color0) ;
    
    return ;
}
</script><!-- end of computeTimeStep shader's source code -->

<!-- ***************************************************************** -->
<script id='click' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * click.frag   : Excite the region that is clicked
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Sun 28 Mar 2021 17:44:32 (EDT)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp int ;
precision highp float ;
precision highp sampler2D ;
precision highp usampler2D ;


// interfacial variables .................................................
in vec2 cc ;

uniform sampler2D   icolor0 ;
uniform sampler2D   compressed3dCrdt ;

uniform sampler2D   projectedCoordinates ;
uniform vec2        clickPosition ;

uniform float       clickRadius ;

// output color ..........................................................
layout (location = 0) out vec4 ocolor0 ;

#define U   color0.r 
/*========================================================================
 * main
 *========================================================================
 */
void main(){
    vec4 color0 = texture( icolor0 , cc ) ;
    vec3 texelCrdt = texture(compressed3dCrdt, cc ).xyz ;
    vec3 clickCrdt = texture(projectedCoordinates, clickPosition ).xyz ; 

    if (length(texelCrdt - clickCrdt )<clickRadius ){
        U = 1. ;
    }

    ocolor0 = vec4(color0) ;
    return ;
}
</script><!-- end of click shader's source code -->


<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- main script - JavaScript code                                     -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<script>
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * app.js       : The main app to bind all shaders together and facilitate
 * the interactions necessary in the app
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 * DATE         : Wed 14 Apr 2021 18:10:57 (EDT)
 * PLACE        : Chaos Lab @ GaTech, Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

"use strict" ;

/*========================================================================
 * get the source code for fragment shaders
 *========================================================================
 */
function source( sid ){
    return  document.getElementById( sid ).innerHTML.trim() ;
}
/*========================================================================
 * Global Parameters
 *========================================================================
 */
let env = {} ;

/*========================================================================
 * import surface data
 *========================================================================
 */
let loadedJSON ;
/*=========================================================================
 * blinkText
 *=========================================================================
 */
//function blinkText(){
//    $('.blink').fadeOut(500) ;
//    $('.blink').fadeIn(500) ;
//}
//setInterval(blinkText, 1000) ;

/*========================================================================
 * let the user select the file
 *========================================================================
 */
//var fileInput = document.getElementById('json_structure') ;
//
//fileInput.onchange = function(){
//  let file = fileInput.files[0] ;
//  if ( !file ){
//      return ;
//  }
//  let reader = new FileReader() ;
//  reader.readAsText(file) ;
//
//  reader.onload = function(e){
//      let result = e.target.result ;
//      loadedJSON = JSON.parse(result) ;
//      $('#chooser').hide() ;
//      $('.loaded').show() ;
//      loadWebGL() ;
//  } ;
//}

/*========================================================================
 * read from file on the server
 *========================================================================
 */
let structureFile = new XMLHttpRequest();

structureFile.onreadystatechange = () => {
    if (structureFile.readyState == 4 && structureFile.status == 200) {
        loadedJSON = JSON.parse(structureFile.responseText);
        console.log(loadedJSON) ;
        loadWebGL() ;
    }
};
structureFile.open("GET", "jsons/structure_pig_192x192x192.json", true);
structureFile.send();
var gl = Abubu.gl ;

/*========================================================================
 * loadWebGL : entry point for the WebGL application
 *========================================================================
 */
function loadWebGL(){
    env.allFloats = [] ;
    env.allInts   = [] ;
    env.allTxtrs  = [] ;

/*------------------------------------------------------------------------
 * display parameters
 *------------------------------------------------------------------------
 */
    env.colormap    = 'rainbowHotSpring' ;
    env.dispWidth   = 512 ;
    env.dispHeight  = 512 ;

    env.canvas_1 = document.getElementById("canvas_1") ;
    env.canvas_2 = document.getElementById("canvas_2") ;
    env.canvas_1.width  = env.dispWidth ;
    env.canvas_1.height = env.dispHeight ;

/*------------------------------------------------------------------------
 * load the structure and process it
 *------------------------------------------------------------------------
 */
    env.mx = loadedJSON.mx ; env.my = loadedJSON.my ;
    env.allInts = [...env.allInts, 'mx','my' ] ;

    env.structure = new Abubu.StructureFromJSON( loadedJSON ) ;

    env.width                   = env.structure.width ;
    env.height                  = env.structure.height ;
    env.fwidth                  = env.structure.fwidth ; 
    env.fheight                 = env.structure.fheight ;

    env.fullTexelIndex          = env.structure.fullTexelIndex ;
    env.compressedTexelIndex    = env.structure.compressedTexelIndex ;
    env.full3dCrdt              = env.structure.full3dCrdt ;
    env.compressed3dCrdt        = env.structure.compressed3dCrdt ;
    env.normals                 = env.structure.normals ;

    env.loaded = true ;

    env.allTxtrs = [...env.allTxtrs, 'compressed3dCrdt' ] ;  
    
/*------------------------------------------------------------------------
 * zero-flux directionator 
 *------------------------------------------------------------------------
 */
    env.dir0 = new Abubu.Uint32Texture( env.width, env.height ) ;
    env.dir1 = new Abubu.Uint32Texture( env.width, env.height ) ;

    env.idir0 = env.dir0 ;
    env.idir1 = env.dir1 ;

    env.directionator = new Abubu.Solver({
        fragmentShader : source('directionator') ,
        uniforms : {
            mx : { type : 'i' , value : env.mx } ,
            my : { type : 'i' , value : env.my } ,
            fullTexelIndex : { 
                type : 't', value : env.fullTexelIndex 
            } ,
            compressedTexelIndex : { 
                type : 't', value : env.compressedTexelIndex
            } ,
        },
        targets: {
            odir0 : { location : 0, target : env.dir0 } ,
            odir1 : { location : 1, target : env.dir1 } ,
        }
    } ) ;
    env.directionator.render() ; 

    env.allTxtrs = [...env.allTxtrs, 'idir0', 'idir1' ] ;

/*------------------------------------------------------------------------
 * textures for time-stepping
 *------------------------------------------------------------------------
 */
    env.fcolors = [] ;
    env.scolors = [] ;

    for(let i=0; i<1; i++){
        env['fcolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env['scolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env.fcolors.push(env['fcolor'+i]) ;
        env.scolors.push(env['scolor'+i]) ;
    }
    env.colors = [ ...env.fcolors, ...env.scolors ] ;

/*------------------------------------------------------------------------
 * init solvers
 *------------------------------------------------------------------------
 */
    // init. .............................................................
    class InitTargets{
        constructor( colors ){
            for(let i=0; i<1 ; i++){
                this["ocolor"+i] = {location : i, target: colors[i]} ;
            }
        }
    }
    env.finit = new Abubu.Solver({
        fragmentShader : source('initSolution') ,
        targets : new InitTargets( env.fcolors ) ,
    } ) ;

    env.sinit = new Abubu.Solver({
        fragmentShader : source('initSolution') ,
        targets : new InitTargets( env.scolors ) ,
    } ) ;

    env.init = function(){
        env.finit.render() ;
        env.sinit.render() ;
    }
    env.init() ;

/*------------------------------------------------------------------------
 * model parameters 
 *------------------------------------------------------------------------
 */
    class Sets{
        constructor(no){
            this.floats = [ 'tau_pv',   'tau_v1',   'tau_v2',   'tau_pw',
                            'tau_mw',   'tau_d' ,   'tau_0' ,   'tau_r' ,
                            'tau_si',   'K'     ,   'V_sic' ,   'V_c'   ,
                            'V_v'   ,   'C_si'  ,] ;
            this.list = [ 
                    'Set 01', 'Set 02', 'Set 03', 'Set 04', 'Set 05', 
                    'Set 06', 'Set 07', 'Set 08', 'Set 09', 'Set 10' ] ;
            this.number = no ;

        } // end of constructor

        get number(){
            return this._no ;
        }
        set number(no){
            this._no = no ;
            switch (this.number){
                case 0: // Set 01
                    this._value = [ 
                        3.33    , 19.6    , 1000    , 667     , 11    ,   
                        0.42    , 8.3     , 50      , 45      , 10    , 
                        0.85    , 0.13    , 0.055   , 1.0     ] ;
                    break ;
                case 1: // Set 02
                    this._value = [
                        10.0    , 10.0    , 10.0    , 667     , 11      ,
                        0.25    , 10.0    , 190     , 45      , 10      ,
                        0.85    , 0.13    , 0.055   , 0.0     ] ;
                    break ;
                case 2: // Set 03
                    this._value = [
                        3.33    , 19.6    , 1250    , 870     , 41      ,
                        0.25    , 12.5    , 33.33   , 29      , 10      ,
                        0.85    , 0.13    , 0.04    , 1.0     ] ;
                    break ;
                case 3: // Set 04
                    this._value = [
                        3.33    , 15.6    , 5       , 350     , 80      ,
                        0.407   , 9       , 34      , 26.5    , 15      ,
                        0.45    , 0.15    , 0.04    , 1.00    ] ;
                    break ;
                case 4: // Set 05
                    this._value = [
                        3.33    , 12      , 2       , 1000    , 100     ,
                        0.362   , 5       , 33.33   , 29      , 15      ,
                        0.70    , 0.13    , 0.04    , 1.00    ] ;
                    break ;
                case 5: // Set 06 
                    this._value = [
                        3.33    , 9       , 8       , 250     , 60      ,
                        0.395   , 9       , 33.33   , 29      , 15      ,
                        0.50    , 0.13    , 0.04    , 1.00    ] ;
                    break ;
                case 6: // Set 07
                    this._value = [
                        10      , 7       , 7       , 250     , 60      ,
                        0.25    , 12      , 100     , 29      , 15      ,
                        0.50    , 0.13    , 0.04    , 0.00    ] ;
                    break ;
                case 7: // Set 08
                    this._value = [
                        13.03   , 19.6    , 1250    , 800     , 40      ,
                        0.45    , 12.5    , 33.25   , 29      , 10      ,
                        0.85    , 0.13    , 0.04    , 1.00    ] ;
                    break ;
                case 8: // Set 09
                    this._value = [
                        3.33    , 15      , 2       , 670     , 61      ,
                        0.25    , 12.5    , 28      , 29      , 10      ,
                        0.45    , 0.13    , 0.05    , 1.00    ] ;
                    break ;
                case 9: // Set 10
                    this._value = [
                        10      , 40      , 333     , 1000    , 65      ,
                        0.115   , 12.5    , 25      , 22.22   , 10      ,
                        0.85    , 0.13    , 0.025   , 1.00    ] ;
                    break ;
            } // end of switch statement
            for(let i in this.floats){
                let name  = this.floats[i] ;
                env[name] = this._value[i] ;
            }
        }// end of set number

        get name(){
            return this.list[this.number] ;
        }
        set name(n){
            for(let i=0; i < this.list.length; i++){
                if(this.list[i] == n){
                    this.number = i ;
                }
            }
        }
        updateSolvers(){
            for(let name of this.floats){
                env.fcomp.uniforms[name].value = env[name] ;
                env.scomp.uniforms[name].value = env[name] ;
            }
        }
    } ;
 
    env.sets = new Sets(3) ;
    env.allFloats.push(...env.sets.floats) ; 
    

    env.diffCoef = 0.001 ;
    env.C_m      = 1. ;
    env.dt       = 0.05 ;
    env.lx       = 8 ;

    env.allFloats.push( 'diffCoef', 'C_m', 'lx','dt' );

/*------------------------------------------------------------------------
 * pacemaker
 *-----------------------------------------------------------------------
 */
    env.pacemakerPeriod = 150 ;
    env.pacemakerPositionX = 0.2 ;
    env.pacemakerPositionY = 0.1 ;
    env.pacemakerRadius = 0.03 ;
    env.pacemakerActive = false ;

    env.pacemakerFloats = [ 'pacemakerPeriod', 'pacemakerPositionX','pacemakerPositionY', 'pacemakerRadius' ] ;
    env.pacemakerBools = [ 'pacemakerActive' ] ;

    env.allFloats.push(...env.pacemakerFloats ) ;
    env.allInts.push( 'pacemakerActive' ) ;
    
/*------------------------------------------------------------------------
 * Time stepping solvers
 *------------------------------------------------------------------------
 */
    // general and common uniforms .......................................
    class CompGeneralUniforms{
        constructor( obj, floats, ints, txtrs){
            for(let name of floats ){
                this[name]  = { type :'f', value : obj[name] } ;
            }
            for(let name of ints){
                this[name]  = { type : 'i', value : obj[name] } ;
            }
            for(let name of txtrs){
                this[name] = { type : 't', value : obj[name] } ;
            }
        }
    }

    // time-step specific uniforms .......................................
    class CompUniforms extends CompGeneralUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs ) ;
            for(let i =0 ; i <1 ; i++){
                this['icolor'+i] = { type: 't', value : _fc[i] } ;
            }
        }
    }

    // time-stepping target ..............................................
    class CompTargets{
        constructor( _fc,_sc ){
            for(let i=0; i<1 ; i++){
                let j = i ;
                this['ocolor'+i] = {location : i, target : _sc[j] } ;
            }
        }
    }

    // time-stepping solvers .............................................
    env.fcomp = new Abubu.Solver({
        fragmentShader : source('computeTimeStep') ,
        uniforms : new CompUniforms(env.fcolors, env.scolors ) ,
        targets  : new CompTargets( env.fcolors, env.scolors ) ,
    } ) ;

    env.scomp = new Abubu.Solver({
        fragmentShader : source('computeTimeStep') ,
        uniforms : new CompUniforms(env.scolors, env.fcolors ) ,
        targets  : new CompTargets( env.scolors, env.fcolors ) ,
    } ) ;

/*------------------------------------------------------------------------
 * display 
 *------------------------------------------------------------------------
 */
    env.visurf = new Abubu.SurfaceVisualizer({
        canvas : canvas_1 ,
        target : env.fcolor0 ,
        structure : env.structure ,
        fovy : 0.45,
        rotation : [1.76,3.25,-1.25] ,
        lightDirection : [ 0.6,0.25,-2.06] ,
        lightSpecularTerm : 0.5, 
        lightAmbientTerm : 0.1, 
        materialSpecularTerm : 5.2 ,
        materialAmbientTerm : 0.1 ,
        shininess : 10 ,
        minValue : 0.1 ,
        maxValue : 0.7 ,
    } ) ;

    env.plot = new Abubu.SignalPlot( {
            noPltPoints : 1024,
            grid        : 'on' ,
            nx          : 5 ,
            ny          : 7 ,
            xticks : { mode : 'auto', unit : 'ms', font:'11pt Times'} ,
            yticks : { mode : 'auto', unit : '', precision : 1 } ,
            canvas      : document.getElementById('canvas_2'),
            legend      : {visible: true , place: 'top-right', 
                location : [0.15,0.05],
                font :"bold 14pt Times",
                length: 0.1} ,

    });

    env.vsgn = env.plot.addSignal( env.fcolor0, {
            channel : 'r',
            name : 'Scaled membrane potential',
            minValue : -0.2 ,
            maxValue : 1.2 ,
            restValue: 0,
            color : [0.5,0,0],
            visible: true,
            linewidth : 3,
            timeWindow: 1000.,
            probePosition : [0.5,0.5] , } ) ;

    env.display = function(){
        env.plot.render() ;
        env.visurf.render() ;

    }

    Object.defineProperty( env, 'probePositionX' , {
        get : ()=>{
            return  env.probePosition[0] ;
        } ,
        set : (nv) =>{
            env.probePosition[0] = nv ;
            env.plot.probePosition = env.probePosition ;
        } 
    } ) ;
    Object.defineProperty( env, 'probePositionY' , {
        get : ()=>{
            return  env.probePosition[1] ;
        } ,
        set : (nv) =>{
            env.probePosition[1] = nv ;
            env.plot.probePosition = env.probePosition ;
        } 
    } ) ;

/*------------------------------------------------------------------------
 * click
 *------------------------------------------------------------------------
 */
    env.click = new Abubu.Solver({
        fragmentShader : source( 'click' ) ,
        uniforms : {
            icolor0 : { type : 't', value : env.fcolor0 } ,
            compressed3dCrdt : { type : 't', 
                value : env.structure.compressed3dCrdt            } ,
            projectedCoordinates : { type : 't', 
                value : env.visurf.projectedCoordinates  } ,
            clickPosition : { type : 'v2', value : [0.,0] } ,
            clickRadius     : { type : 'f', value : 0.1 } ,
        } ,
        targets : {
            ocolor0 : { location : 0 , target : env.scolor0 } ,
        }
    } ) ;

    env.clickCopy = new Abubu.Copy( env.scolor0, env.fcolor0 ) ;
    
    env.cmndClick = new Abubu.CommandClickListener(
        canvas_1 , (e) =>{
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.cntrlClick = new Abubu.CtrlClickListener(
        canvas_1 , (e) =>{
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.shiftClick = new Abubu.ShiftClickListener(
        canvas_1,
        (e)=>{
            var clickCompPosition = 
            env.visurf.getCompressedClickPosition(e.position);
            env.plot.setProbePosition( clickCompPosition ) ;
            env.plot.init() ;
        } ) ;

/*------------------------------------------------------------------------
 * save and reload
 *------------------------------------------------------------------------
 */
    class SaveAndReload{
        constructor(opt){
            this.jsonObject = {}  ;
            this.filename = opt?.filename ?? '3v-save' ;
            this.comments = opt?.comments ?? '' ;

            this.loader = document.createElement( 'input' ) ;
            this.loader.setAttribute( 'type', 'file' ) ;

            // read the chose files
            this.loader.onchange = ()=>{
                if( !this.loader.files[0] ){
                    console.log('No file selected') ;
                }

                let reader = new FileReader() ;

                let file = this.loader.files[0] ;
                reader.readAsText(file) ;

                reader.onload = (e) =>{
                    let result  = event.target.result ;
                    let json = JSON.parse(result) ;
                    // read floats from json
                    for(let name of env.allFloats)
                        env[name] = json[name] ;
                    env.time = json.time ;

                    // read ints from json
                    for(let name of env.allInts)
                        env[name] = json[name] ;

                    this.comments = json.comments ;

                    env.GUI.updateDisplay() ;

                    // update textures from json
                    env.fcolor0.data = new Float32Array( json.color0 ) ; 
                    env.scolor0.data = new Float32Array( json.color0 ) ; 

                    // recalculate zero flux directions
                    //     } ) ;
                }
            }
        } /* End of constructor */

        reload(){
            this.loader.click() ;
        }

        save(){
            this.jsonObject.comments = this.comments ;

            // add all floats to the jsonObject ..........................
            for(let name of env.allFloats)
                this.jsonObject[name] = env[name] ;
            this.jsonObject.time = env.time ;

            // add all integers to the jsonObject ........................
            for(let name of env.allInts)
                this.jsonObject[name] = env[name] ;
        
            // add texture values to the json ............................
            this.jsonObject.color0 = Array.from(env.fcolor0.value) ;
            
            let json = "data:text;charset=utf-8," + 
                JSON.stringify(this.jsonObject) ;
            let data = encodeURI( json ) ;
            
            let link = document.createElement('a') ;
            link.setAttribute( 'href', data ) ;
            link.setAttribute( 'download', this.filename +'.json') ;
            link.click() ;
        }
    } ;

    env.saveAndReload = new SaveAndReload() ;

/*------------------------------------------------------------------------
 * Editors 
 *------------------------------------------------------------------------
 */
    env.editor = new Abubu.Editor({
        sources : { 
            initialCondition : {
                source : source('initSolution' ) ,
                solvers : [ env.finit , env.sinit ] ,
                title : 'Initial Condition Shader' ,
                filename : 'initCondition.frag',
            } ,
            computeTimeStep : {
                source : source( 'computeTimeStep' ) ,
                solvers : [ env.fcomp, env.scomp ] ,
                title : 'Time Stepping Shader' ,
                filename : 'computeTimeStep.frag', 
            } ,
            clickSolver : { 
                source : source( 'click' ) ,
                title  : 'Click Shader' ,
                filename : 'click.frag', 
                solvers : [ env.clickSolver ],
            }
        } ,
        id : 'editor',
        active : 'computeTimeStep' ,
    } ) ;
    
    env.toggleEditor = function(){
        $("#editorSection").fadeToggle(300)
    } ;

/*------------------------------------------------------------------------
 * initialize 
 *------------------------------------------------------------------------
 */
    env.initialize = function(){
        env.finit.render() ;
        env.sinit.render() ;
        env.plot.init(0) ;
        env.time = 0 ;
    }
    env.initialize() ;

/*------------------------------------------------------------------------
 * main time loop
 *------------------------------------------------------------------------
 */
    env.running = false ;
    env.skip = 10 ;

    env.solveOrPause = function(){
        env.running = !env.running ;
    }

    env.run = function(){
        if(env.running){
            for(let i=0 ; i<env.skip ; i++){
                env.fcomp.render() ;
                env.scomp.render() ;
                env.time += env.dt*2. ;
                env.vsgn.update(env.time) ;
            }
        }
        env.display();

        requestAnimationFrame(env.run) ;
    }


    createGUI() ;
    env.run() ;

    return ;
} // end of loadWebGL

/*========================================================================
 * add multiple parameters to the GUI
 *========================================================================
 */ 
function addToGui( 
        guiElemenent ,  // gui element to add options into
        obj,            // object that holds parameters
        paramList,      // array of strings that contains list 
                        // of parmeters to be added
        solverList      // array of solvers that need to be update upon 
                        // change of a parameter through gui interactions
    ){
    let elements = {} ;
    for(let param of paramList){
        elements[param] = 
            guiElemenent.add(obj, param ).onChange( ()=> {
                Abubu.setUniformInSolvers( 
                    param, obj[param], solverList ) ;
            } ) ;
    }
    return elements ;
}

/*========================================================================
 * createGUI : create the graphical user interface
 *========================================================================
 */
function createGUI(){
    env.GUI = new Abubu.Gui() ;
    env.panel1 = env.GUI.addPanel({width:400}) ;
    let p1 = env.panel1 ;

    // model parameters ..................................................
    p1.model = p1.addFolder('Model Parameters') ;
    p1.model
        .add( env.sets, 'name', env.sets.list )
        .name('Parameter Set')
        .onChange(
            () =>{
                p1.model.updateDisplay() ;
                env.sets.updateSolvers() ;
            } ) ;
    addToGui( p1.model, env, env.allFloats , [env.fcomp, env.scomp] ) ;


    // clicker ...........................................................
//    p1.clicker = p1.addFolder('Mouse Click Settings' ) ;
//    p1.clicker.add( env.clicker, 'type', env.clicker.types ) ;
//    p1.clicker.add( env.clicker, 'radius' ).step(0.001).min(0) ;

    // pacemaker .........................................................
//    p1.pacemaker = p1.addFolder('Pacemaker' ) ;    
//    addToGui( p1.pacemaker, env, [...env.pacemakerFloats,...env.pacemakerBools], [env.fcomp, env.scomp] ) ;
    
    // display options ...................................................
    p1.display = p1.addFolder('Visualization options') ;
    p1.display.visurf = env.visurf.controlByGui( p1.display ) ;

//    p1.display.add( env, 'probePositionX' ) ;
//    p1.display.add( env, 'probePositionY' ) ;
//    p1.display.add( env.plot, 'timeWindow') ;

    // source code editos ................................................
    p1.source  = p1.addFolder('Edit/Save/Load Source Code') ;
    p1.source.add( env , 'toggleEditor').name('Show/Hide Editor' ) ;
    p1.source.add( env.editor , 'title', env.editor.titles ).name('Edit source').onChange( ()=>{ p1.updateDisplay() ;} ) ;
    p1.source.add( env.editor , 'filename').name('Filename') ;
    p1.source.add( env.editor , 'save' ).name('Save to file') ;
    p1.source.add( env.editor , 'load' ).name('Load from file') ;
    
    // save and load .....................................................
    p1.save = p1.addFolder('Save and Reload Simulation') ;
    p1.save.add(env.saveAndReload , 'comments' ) ;
    p1.save.add(env.saveAndReload , 'filename' ) ;
    p1.save.add(env.saveAndReload , 'save' ) ;
    p1.save.add(env.saveAndReload,  'reload' ) ;

    // simulation ........................................................
    p1.exe = p1.addFolder('Execution'  ) ;
    p1.exe.add( env, 'time' ).listen() ;
    p1.exe.add( env, 'skip'             ).min(1).step(1) ;
    p1.exe.add( env, 'initialize'       ).name('Initialize Simulation');
    p1.exe.add( env, 'solveOrPause'     ).name('Start/Pause simulation') ;

    p1.exe.open() ;

    return ;
}
</script>


</body>
</html>

